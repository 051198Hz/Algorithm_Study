
let sp = readLine()!.split { $0 == " " }.map { Int(String($0))! }
//첫 번째 줄에 민호가 임의로 만든 DNA 문자열 길이 |S|와
//비밀번호로 사용할 부분문자열의 길이 |P| 가 주어진다. (1 ≤ |P| ≤ |S| ≤ 1,000,000)
let acgt = ["A": 0, "C": 1, "G": 2, "T": 3]
let dna: [String] = readLine()!.map { String($0) }
let acgtMin = readLine()!.split { $0 == " " }.map { Int(String($0))! }
//임의의 DNA문자열이 “AAACCTGCCAA” 이고 민호가 뽑을 부분문자열의 길이를 4라고 하자.
//그리고 부분문자열에 ‘A’ 는 1개 이상, ‘C’는 1개 이상, ‘G’는 1개 이상, ‘T’는 0개 이상이 등장해야 비밀번호로 사용할 수 있다고 하자.
//이때 “ACCT” 는 ‘G’ 가 1 개 이상 등장해야 한다는 조건을 만족하지 못해 비밀번호로 사용하지 못한다. 하지만 “GCCA” 은 모든 조건을 만족하기 때문에 비밀번호로 사용할 수 있다.
//민호가 만든 임의의 DNA 문자열과 비밀번호로 사용할 부분분자열의 길이,
//그리고 {‘A’, ‘C’, ‘G’, ‘T’} 가 각각 몇번 이상 등장해야 비밀번호로 사용할 수 있는지 순서대로 주어졌을 때
//민호가 만들 수 있는 비밀번호의 종류의 수를 구하는 프로그램을 작성하자.
//단 부분문자열이 등장하는 위치가 다르다면 부분문자열이 같다고 하더라도 다른 문자열로 취급한다.

// 부분문자열이 등장하는 위치가 다르다는 말이 무슨말일까?
// 원소가 같더라도 원소의 순서가 다르다면 다른 문자열로 취급한다는 말일까?
// 아니면 원본문자열에서 뽑는 위치가 다를 때 얘기일까. 근데 상식적으로 비밀번호니 부분문자열 내의 순서를 말할 것 같다.

// 먼저 부분문자열을 뽑는 방법을 생각해보자.
// DFS? BSF? 백트래킹일 것 같다.
// 1000000C500000 는 수가 무지막지하게 크다. DFS는 아닐 것 같다. BFS도 아닐 것 같다.
// 비밀번호를 만들면서 각각 들어가야할 것들을 알 수는 없다. 비밀번호를 다 만든 후에 검사할 수 있다.
// 비밀번호를 다 만든 후에 검사하려면 모든 경우를 탐색한 후 조건에 맞는지 검사한다는 이야기인데, 시간적 비용이 조건을 초과한다.
// 비밀번호를 만들어가면서 조건에 맞는 경우들을 찾아갈 수 있는 방법이 있을까?
// 예를들면, A가 4개 이상이니 A를 먼저 4개 이상 확보한 경우,,

//아니면 문자열 내에 등장하는 문자의 갯수를 먼저 저장한 후
//여기에서 순서를 바꿔간다..
// 근데 어떤 문자는 어떤 문자보다 앞에 있으니 그렇게는 어렵다.
// 즉 이건 순서가 있는 순열을 세는 문제, 순열 문제이다.
//

//아니면, 남은 문자열에 해당하는 다음 원소를 찾고, 그렇게 가지를 펼치는 방법,,,
//근데 이것도 백만의 앞자리부터 탐색했을 때 시간초과할 것 같다.
//결국 부분문자열을 탐색할 때 시간을 줄이는 자료구조나 알고리즘을 활용해야 할 것 같은데. 트리?

// 아 뭐야.. 부분 문자열이란 문자열 내에서 연속하는 일련의 문자들을 부르는 말이다.
// 그러면 슬라이딩 윈도우로 쌉가능이지 z
var acgtCount = [Int](repeating: 0, count: 4)
var answer = 0
var start = 0
var end = 0
while end < sp[1] {
    let dnaWord = dna[end]
    let order = acgt[dnaWord]!
    acgtCount[order] += 1
    end += 1
}
while end <= dna.count {
    let count = acgt.map { key, value in (acgtMin[value] <= acgtCount[value]) ? 1:0 }.reduce(0, +)
    if count >= 4 { answer += 1 }
    if end >= dna.count { break }
    acgtCount[acgt[dna[start]]!] -= 1
    acgtCount[acgt[dna[end]]!] += 1
    start += 1
    end += 1
}
print(answer)